import{_ as e,V as a,W as o,a1 as t}from"./framework-5e2051d8.js";const r={},c=t('<h2 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则" aria-hidden="true">#</a> 设计原则</h2><h3 id="_1-单一职责原则" tabindex="-1"><a class="header-anchor" href="#_1-单一职责原则" aria-hidden="true">#</a> 1.单一职责原则 :###</h3><blockquote><p>一个类只负责一个功能领域中的相应职责</p></blockquote><h3 id="_2-开闭原则" tabindex="-1"><a class="header-anchor" href="#_2-开闭原则" aria-hidden="true">#</a> 2. 开闭原则 :</h3><blockquote><p>一个软件实体应当对扩展开放，对修改关闭</p></blockquote><h3 id="_3-里氏代换原则" tabindex="-1"><a class="header-anchor" href="#_3-里氏代换原则" aria-hidden="true">#</a> 3. 里氏代换原则 :</h3><blockquote><p>所有应用基类（父类）的地方，必须能透明的使用其子类对象</p></blockquote><ol><li>使用原则 : 在程序设计时,尽量使用基类类型对对象进行定义,而在运行时再确定子类类型,用子类对象替换父类对象</li></ol><h3 id="_4-依赖倒转原则" tabindex="-1"><a class="header-anchor" href="#_4-依赖倒转原则" aria-hidden="true">#</a> 4. 依赖倒转原则</h3><blockquote><p>抽象不应该依赖于细节,细节应当依赖于抽象.换言之就是,要面向接口编程,而不是针对实现编程.</p></blockquote><blockquote><p>程序代码中传递参数或关联关系时,尽量应用层次高的抽象层类,既使用抽象类,接口进行变量类型声明,参数声明,返回值类型声明,以及数据类型的转换等,而不要用具体的类来做这些事.</p></blockquote>',11),h=[c];function d(i,l){return a(),o("div",null,h)}const _=e(r,[["render",d],["__file","Java设计模式.html.vue"]]);export{_ as default};
